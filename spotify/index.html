<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Authentication - DECK</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="stylesheet" href="../styles.css">
    <style>
        /* Callback-specific styles only */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .callback-container {
            text-align: center;
            background: var(--card-background);
            padding: 2rem;
            border-radius: 12px;
            box-shadow: var(--shadow-lg);
            max-width: 500px;
            width: 90%;
            color: var(--text-color);
        }

        .callback-container h1 {
            color: var(--primary-color);
            margin-bottom: 1rem;
        }

        .spinner {
            border: 3px solid var(--border-color);
            border-top: 3px solid var(--spotify-green);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 1rem;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            color: var(--error-color);
            background: var(--error-background);
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
        }

        .success {
            color: var(--success-color);
            background: var(--success-background);
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
        }

        .hidden {
            display: none;
        }

        .logo {
            font-size: 2rem;
            margin-bottom: 1rem;
        }
    </style>
</head>
<body>
    <div class="callback-container">
        <div id="loading-state">
            <div class="logo">
                <i class="fab fa-spotify"></i>
            </div>
            <div class="spinner"></div>
            <h2 id="loading-message">Creating your Spotify playlist...</h2>
            <p id="loading-description">Please wait while we set up your playlist.</p>
        </div>

        <div id="error-state" class="hidden">
            <div class="logo">
                <i class="fas fa-exclamation-triangle"></i>
            </div>
            <h2>Error</h2>
            <div id="error-message" class="error"></div>
            <p>This tab will close automatically, or you can close it manually.</p>
        </div>

        <div id="success-state" class="hidden">
            <div class="logo">
                <i class="fas fa-check-circle"></i>
            </div>
            <h2>Playlist Created!</h2>
            <div id="success-message" class="success"></div>
            <p>Redirecting you to your new playlist...</p>
        </div>
    </div>

    <script>
        // Spotify Playlist Creation Handler
        const CONFIG = {
            CLIENT_ID: '9801203f29414b42a749637524f1fc48',
            AUTH_BASE_URL: 'https://accounts.spotify.com',
            API_BASE_URL: 'https://api.spotify.com/v1',
            REDIRECT_URI: window.location.href.split('?')[0], // Current page
            SCOPES: ['playlist-modify-private', 'user-read-private']
        };

        const elements = {
            loadingState: document.getElementById('loading-state'),
            errorState: document.getElementById('error-state'),
            successState: document.getElementById('success-state'),
            errorMessage: document.getElementById('error-message'),
            successMessage: document.getElementById('success-message'),
            loadingMessage: document.getElementById('loading-message'),
            loadingDescription: document.getElementById('loading-description')
        };

        function updateLoadingMessage(message, description = '') {
            elements.loadingMessage.textContent = message;
            elements.loadingDescription.textContent = description;
        }

        function showError(message) {
            elements.loadingState.classList.add('hidden');
            elements.errorState.classList.remove('hidden');
            elements.errorMessage.textContent = message;

            // Auto-close tab after error
            setTimeout(() => {
                window.close();
            }, 5000);
        }

        function showSuccess(message, playlistUrl) {
            elements.loadingState.classList.add('hidden');
            elements.successState.classList.remove('hidden');
            elements.successMessage.textContent = message;

            // Redirect to playlist after short delay
            setTimeout(() => {
                window.location.href = playlistUrl;
            }, 1000);
        }

        // Utility functions for PKCE
        function generateCodeVerifier() {
            const array = new Uint8Array(32);
            crypto.getRandomValues(array);
            return btoa(String.fromCharCode.apply(null, array))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        async function generateCodeChallenge(verifier) {
            const encoder = new TextEncoder();
            const data = encoder.encode(verifier);
            const digest = await crypto.subtle.digest('SHA-256', data);
            return btoa(String.fromCharCode.apply(null, new Uint8Array(digest)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        function generateRandomState() {
            const array = new Uint8Array(16);
            crypto.getRandomValues(array);
            return btoa(String.fromCharCode.apply(null, array))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        // Check if we have a valid access token
        function isTokenValid() {
            const expiresAt = localStorage.getItem('spotify_token_expires_at');
            return expiresAt && Date.now() < parseInt(expiresAt);
        }

        function getAccessToken() {
            if (isTokenValid()) {
                return localStorage.getItem('spotify_access_token');
            }
            return null;
        }

        // Generate playlist name
        function generatePlaylistName() {
            const timestamp = new Date().toLocaleString('en-US', {
                month: 'numeric',
                day: 'numeric',
                year: 'numeric',
                hour: 'numeric',
                minute: '2-digit',
                hour12: true
            });
            return `DECK pull - ${timestamp}`;
        }

        // Convert Spotify URLs to URIs
        function convertUrlsToUris(spotifyUrls) {
            return spotifyUrls
                .map(url => {
                    const match = url.match(/track\/([a-zA-Z0-9]+)/);
                    return match ? `spotify:track:${match[1]}` : null;
                })
                .filter(uri => uri);
        }

        // API functions
        async function getCurrentUser(accessToken) {
            const response = await fetch(`${CONFIG.API_BASE_URL}/me`, {
                headers: {
                    'Authorization': `Bearer ${accessToken}`
                }
            });

            if (!response.ok) {
                throw new Error(`Failed to get user profile: ${response.status}`);
            }

            return await response.json();
        }

        async function createPlaylist(accessToken, userId, playlistName) {
            const response = await fetch(`${CONFIG.API_BASE_URL}/users/${userId}/playlists`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: playlistName,
                    description: 'From the DECK deck.',
                    public: false
                })
            });

            if (!response.ok) {
                throw new Error(`Failed to create playlist: ${response.status}`);
            }

            return await response.json();
        }

        async function addTracksToPlaylist(accessToken, playlistId, trackUris) {
            const response = await fetch(`${CONFIG.API_BASE_URL}/playlists/${playlistId}/tracks`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    uris: trackUris
                })
            });

            if (!response.ok) {
                throw new Error(`Failed to add tracks to playlist: ${response.status}`);
            }

            return await response.json();
        }

        // OAuth flow
        async function initiateSpotifyAuth(spotifyUrls) {
            const codeVerifier = generateCodeVerifier();
            const codeChallenge = await generateCodeChallenge(codeVerifier);
            const state = generateRandomState();

            // Store for callback
            localStorage.setItem('spotify_code_verifier', codeVerifier);
            localStorage.setItem('spotify_auth_state', state);
            localStorage.setItem('spotify_playlist_urls', JSON.stringify(spotifyUrls));

            // Build authorization URL
            const params = new URLSearchParams({
                response_type: 'code',
                client_id: CONFIG.CLIENT_ID,
                scope: CONFIG.SCOPES.join(' '),
                redirect_uri: CONFIG.REDIRECT_URI,
                code_challenge_method: 'S256',
                code_challenge: codeChallenge,
                state: state
            });

            const authUrl = `${CONFIG.AUTH_BASE_URL}/authorize?${params}`;
            window.location.href = authUrl;
        }

        async function handleCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const state = urlParams.get('state');
            const error = urlParams.get('error');

            if (error) {
                throw new Error(`Spotify authorization error: ${error}`);
            }

            if (!code || !state) {
                throw new Error('Missing required OAuth parameters');
            }

            // Verify state
            const storedState = localStorage.getItem('spotify_auth_state');
            if (state !== storedState) {
                throw new Error('Invalid state parameter');
            }

            // Get code verifier
            const codeVerifier = localStorage.getItem('spotify_code_verifier');
            if (!codeVerifier) {
                throw new Error('Code verifier not found');
            }

            updateLoadingMessage('Exchanging authorization code...', 'Getting access token from Spotify.');

            // Exchange code for token
            const tokenResponse = await fetch(`${CONFIG.AUTH_BASE_URL}/api/token`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/x-www-form-urlencoded',
                },
                body: new URLSearchParams({
                    grant_type: 'authorization_code',
                    code: code,
                    redirect_uri: CONFIG.REDIRECT_URI,
                    client_id: CONFIG.CLIENT_ID,
                    code_verifier: codeVerifier,
                }),
            });

            const tokenData = await tokenResponse.json();
            if (!tokenResponse.ok) {
                throw new Error(`Token exchange failed: ${tokenData.error_description || tokenData.error}`);
            }

            // Store tokens
            localStorage.setItem('spotify_access_token', tokenData.access_token);
            if (tokenData.refresh_token) {
                localStorage.setItem('spotify_refresh_token', tokenData.refresh_token);
            }
            localStorage.setItem('spotify_token_expires_at', Date.now() + (tokenData.expires_in * 1000));

            // Clean up OAuth state
            localStorage.removeItem('spotify_code_verifier');
            localStorage.removeItem('spotify_auth_state');

            return tokenData.access_token;
        }

        async function createSpotifyPlaylist(spotifyUrls, accessToken) {
            updateLoadingMessage('Getting your profile...', 'Retrieving user information from Spotify.');

            // Get user profile
            const user = await getCurrentUser(accessToken);

            updateLoadingMessage('Creating playlist...', 'Setting up your new DECK playlist.');

            // Create playlist
            const playlistName = generatePlaylistName();
            const playlist = await createPlaylist(accessToken, user.id, playlistName);

            updateLoadingMessage('Adding tracks...', `Adding ${spotifyUrls.length} songs to your playlist.`);

            // Convert URLs to URIs and add tracks
            const trackUris = convertUrlsToUris(spotifyUrls);
            if (trackUris.length === 0) {
                throw new Error('No valid Spotify tracks found');
            }

            await addTracksToPlaylist(accessToken, playlist.id, trackUris);

            return playlist;
        }

        async function main() {
            try {
                const urlParams = new URLSearchParams(window.location.search);
                const isCallback = urlParams.has('code') && urlParams.has('state');

                let accessToken = getAccessToken();
                let spotifyUrls;

                if (isCallback) {
                    // This is the OAuth callback
                    updateLoadingMessage('Completing authentication...', 'Processing Spotify authorization.');
                    accessToken = await handleCallback();

                    // Get saved URLs
                    const savedUrls = localStorage.getItem('spotify_playlist_urls');
                    if (!savedUrls) {
                        throw new Error('No saved playlist data found');
                    }
                    spotifyUrls = JSON.parse(savedUrls);
                } else {
                    // Initial load - get URLs from localStorage
                    const savedUrls = localStorage.getItem('spotify_playlist_urls');
                    if (!savedUrls) {
                        throw new Error('No playlist data found. Please return to the main app and try again.');
                    }
                    spotifyUrls = JSON.parse(savedUrls);

                    if (!accessToken) {
                        // Need to authenticate
                        updateLoadingMessage('Redirecting to Spotify...', 'You need to authorize this app to create playlists.');
                        await initiateSpotifyAuth(spotifyUrls);
                        return; // Will redirect
                    }
                }

                // Create playlist
                const playlist = await createSpotifyPlaylist(spotifyUrls, accessToken);

                // Clean up
                localStorage.removeItem('spotify_playlist_urls');

                // Success!
                showSuccess(
                    `Created "${playlist.name}" with ${spotifyUrls.length} tracks!`,
                    playlist.external_urls.spotify
                );

            } catch (error) {
                console.error('Playlist creation error:', error);
                showError(error.message || 'Failed to create playlist. Please try again.');

                // Clean up on error
                localStorage.removeItem('spotify_code_verifier');
                localStorage.removeItem('spotify_auth_state');
            }
        }

        // Start when page loads
        window.addEventListener('load', main);

        // Fallback: close tab if stuck
        setTimeout(() => {
            if (!elements.successState.classList.contains('hidden') ||
                !elements.errorState.classList.contains('hidden')) {
                return; // Already completed
            }
            showError('Process took too long. Please try again.');
        }, 30000);
    </script>
</body>
</html>
